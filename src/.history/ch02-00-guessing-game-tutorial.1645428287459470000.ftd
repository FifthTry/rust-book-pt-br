-- ft.doc-page:
toc: $ft.toc

-- ft.h1: Jogo de Adivinha√ß√£o


Vamos entrar de cabe√ßa no Rust e colocar a m√£o na massa! Este cap√≠tulo vai lhe
apresentar alguns conceitos bem comuns no Rust, mostrando como us√°-los em um
programa de verdade. Voc√™ vai aprender sobre `let`, `match`, m√©todos, fun√ß√µes
associadas, crates externos, e mais! Os cap√≠tulos seguintes v√£o explorar essas
ideias em mais detalhes. Neste cap√≠tulo, voc√™ vai praticar o b√°sico.

Vamos implementar um cl√°ssico problema de programa√ß√£o para iniciantes: um jogo
de adivinha√ß√£o. Eis como ele funciona: o programa vai gerar um n√∫mero inteiro
aleat√≥rio entre 1 e 100. Ent√£o, ele vai pedir ao jogador que digite um palpite.
Ap√≥s darmos nosso palpite, ele vai nos indicar se o palpite √© muito baixo ou
muito alto. Uma vez que o palpite estiver correto, ele vai nos dar os parab√©ns e
sair.

-- ft.h2: Preparando um Novo Projeto


Para iniciar um novo projeto, v√° ao seu diret√≥rio de projetos que voc√™ criou no
Cap√≠tulo 1, e execute os comandos do Cargo a seguir:

-- ft.code:
lang: text

\$ cargo new jogo_de_advinhacao --bin
\$ cd jogo_de_advinhacao


-- ft.markdown:

O primeiro comando, `cargo new`, recebe o nome do projeto (`jogo_de_advinhacao`)
como primeiro argumento. A flag `--bin` diz ao Cargo que fa√ßa um projeto
bin√°rio, similar ao do Cap√≠tulo 1. O segundo comando muda a pasta atual para o
diret√≥rio do projeto.

-- ft.markdown:

Confira o arquivo *Cargo.toml* gerado:

-- ft.markdown:

<span class="filename">Arquivo: Cargo.toml</span>

-- ft.code:
lang: toml

[package]
name = "jogo_de_advinhacao"
version = "0.1.0"
authors = ["Seu Nome <voce@exemplo.com>"]

[dependencies]


-- ft.markdown:

Se as informa√ß√µes sobre o autor, que o Cargo obt√©m do seu ambiente, n√£o
estiverem corretas, fa√ßa os reparos necess√°rios e salve o arquivo.

-- ft.markdown:

Assim como no Cap√≠tulo 1, `cargo new` gera um programa "Hello, world!" para n√≥s.
Confira em *src/main.rs*:

-- ft.markdown:

<span class="filename">Arquivo: src/main.rs</span>

-- ft.code:
lang: rust

fn main() {
    println!("Hello, world!");
}


-- ft.markdown:

Agora vamos compilar esse programa "Hello, world!" e execut√°-lo de uma vez s√≥
usando o comando `cargo run`:

-- ft.code:
lang: text

\$ cargo run
   Compiling jogo_de_advinhacao v0.1.0 (file:///projects/jogo_de_advinhacao)
    Finished dev [unoptimized + debuginfo] target(s) in 1.50 secs
     Running `target/debug/jogo_de_advinhacao`
Hello, world!


-- ft.markdown:

O comando `run` √© uma boa op√ß√£o quando precisamos iterar rapidamente em um
projeto, que √© o caso neste jogo: n√≥s queremos testar rapidamente cada itera√ß√£o
antes de movermos para a pr√≥xima.

-- ft.markdown:

Abra novamente o arquivo *src/main.rs*. Escreveremos todo nosso c√≥digo nele.

-- ft.h2: Processando um Palpite


A primeira parte do programa vai pedir uma entrada ao usu√°rio, processar essa
entrada, e conferir se ela est√° no formato esperado. Pra come√ßar, vamos permitir
que o jogador entre com um palpite. Coloque este c√≥digo no arquivo
*src/main.rs*:

<span class="filename">Arquivo: src/main.rs</span>

-- ft.code:
lang: rust,ignore

use std::io;

fn main() {
    println!("Advinhe o n√∫mero!");

    println!("Digite o seu palpite.");

    let mut palpite = String::new();

    io::stdin().read_line(&mut palpite)
        .expect("Falha ao ler entrada");

    println!("Voc√™ disse: {}", palpite);
}


-- ft.markdown:

<span class="caption">Listagem 2-1: C√≥digo para ler um palpite do usu√°rio e
imprim√≠-lo na tela.</span>

-- ft.markdown:

Esse c√≥digo tem muita informa√ß√£o, vamos ver uma parte de cada vez. Para obter a
entrada do usu√°rio, e ent√£o imprimir o resultado como sa√≠da, precisaremos trazer
ao escopo a biblioteca `io` (de entrada/sa√≠da). A biblioteca `io` prov√©m da
biblioteca padr√£o (chamada de `std`):

-- ft.code:
lang: rust,ignore

use std::io;


-- ft.markdown:

Por padr√£o, o Rust traz apenas alguns tipos para o escopo de todos os programas
no [*prel√∫dio*](../../std/prelude/index.html)<!-- ignore -->. Se um tipo que voc√™ quiser usar n√£o
estiver no prel√∫dio, voc√™ ter√° que import√°-lo explicitamente atrav√©s do `use`.
A biblioteca `std::io` oferece v√°rias ferramentas de entrada/sa√≠da, incluindo a
funcionalidade de ler dados de entrada do usu√°rio.



-- ft.markdown:

Como visto no Cap√≠tulo 1, a fun√ß√£o `main` √© o ponto de entrada do programa:

-- ft.code:
lang: rust,ignore

fn main() {


-- ft.markdown:

A sintaxe `fn` declara uma nova fun√ß√£o, o `()` indica que n√£o h√° par√¢metros, e
o `{` inicia o corpo da fun√ß√£o.

-- ft.markdown:

Como voc√™ tamb√©m j√° aprendeu no Cap√≠tulo 1, `println!` √© uma macro que imprime
uma string na tela:

-- ft.code:
lang: rust,ignore

println!("Advinhe o n√∫mero!");

println!("Digite o seu palpite.");


-- ft.markdown:

Este c√≥digo est√° exibindo uma mensagem que diz de que se trata o jogo e solicita
uma entrada do usu√°rio.  

-- ft.h3: Armazenando Valores em Vari√°veis


Pr√≥ximo passo, vamos criar um local para armazenar a entrada do usu√°rio:

-- ft.code:
lang: rust,ignore

let mut palpite = String::new();


-- ft.markdown:

Agora o programa est√° ficando interessante! Tem muita coisa acontecendo nesta
pequena linha. Repare que esta √© uma declara√ß√£o `let`, que √© usada para criar
*vari√°veis*. Segue outro exemplo:

-- ft.code:
lang: rust,ignore

let foo = bar;


-- ft.markdown:

Essa linha cria uma nova vari√°vel chamada `foo`, e a vincula ao valor `bar`. Em
Rust, vari√°veis s√£o imut√°veis por padr√£o. O exemplo a seguir mostra como usar
`mut` antes do nome da vari√°vel para torn√°-la mut√°vel:

-- ft.code:
lang: rust

let foo = 5; // imut√°vel
let mut bar = 5; // mut√°vel


-- ft.markdown:

> Nota: A sintaxe `//` inicia um coment√°rio, que continua at√© o fim da linha.
> Rust ignora tudo o que estiver nos coment√°rios.

-- ft.markdown:

Agora voc√™ sabe que `let mut palpite` vai introduzir uma vari√°vel mut√°vel de
nome `palpite`. No outro lado do s√≠mbolo `=` est√° o valor ao qual `palpite` est√°
vinculado, que √© o resultado da chamada `String::new`, uma fun√ß√£o que retorna
uma nova inst√¢ncia de `String`. [`String`](../../std/string/struct.String.html)<!-- ignore --> √© um tipo
fornecido pela biblioteca padr√£o que representa uma cadeia expans√≠vel de
caracteres codificados em UTF-8.



-- ft.markdown:

A sintaxe `::` na linha `::new` indica que `new` √© uma *fun√ß√£o associada* do
tipo `String`. Uma fun√ß√£o associada √© implementada sobre um tipo, neste caso
`String`, em vez de uma inst√¢ncia particular de `String`. Algumas linguagens
d√£o a isso o nome *m√©todo est√°tico*.

-- ft.markdown:

Esta fun√ß√£o `new()` cria uma nova `String` vazia. Voc√™ encontrar√° uma fun√ß√£o
`new()` em muitos tipos, j√° que √© um nome comum para uma fun√ß√£o que produz um
novo valor de algum tipo.

-- ft.markdown:

Para resumir, a linha `let mut palpite = String::new();` criou uma vari√°vel
mut√°vel que est√° atualmente vinculada a uma nova inst√¢ncia vazia de uma
`String`. Ufa!

-- ft.markdown:

Lembre-se de que inclu√≠mos a funcionalidade de entrada/sa√≠da da biblioteca
padr√£o por meio do `use std::io;` na primeira linha do programa. Agora vamos
chamar uma fun√ß√£o associada, `stdin`, em `io`:

-- ft.code:
lang: rust,ignore

io::stdin().read_line(&mut palpite)
    .expect("Falha ao ler entrada");


-- ft.markdown:

Se n√£o tiv√©ssemos a linha `use std::io` no in√≠cio do programa, poder√≠amos ter
escrito esta chamada como `std::io::stdin`. A fun√ß√£o `stdin` retorna uma
inst√¢ncia de [`std::io::Stdin`](../../std/io/struct.Stdin.html)<!-- ignore -->, um tipo que representa
um manipulador (_handle_) da entrada padr√£o do seu terminal.



-- ft.markdown:

A pr√≥xima parte do c√≥digo, `.read_line(&mut palpite)`, chama o m√©todo
[`read_line`](../../std/io/struct.Stdin.html#method.read_line)<!-- ignore --> do _handle_ da entrada padr√£o para obter
entrada do usu√°rio. Tamb√©m estamos passando um argumento para `read_line`:
`&mut palpite`.



-- ft.markdown:

O trabalho da fun√ß√£o `read_line` √© receber o que o usu√°rio digita na entrada
padr√£o e colocar isso numa string, por isso ela recebe essa string como
argumento. A string do argumento deve ser mut√°vel para que o m√©todo consiga
alterar o seu conte√∫do, adicionando a entrada do usu√°rio.

-- ft.markdown:

O s√≠mbolo `&` indica que o argumento √© uma *refer√™ncia*, o que permite m√∫ltiplas
partes do seu c√≥digo acessar um certo dado sem precisar criar v√°rias c√≥pias dele
na mem√≥ria. Refer√™ncias s√£o uma caracter√≠stica complexa, e uma das maiores
vantagens do Rust √© o qu√£o f√°cil e seguro √© usar refer√™ncias. Voc√™ n√£o precisa
conhecer muitos desses detalhes para finalizar esse programa. O Cap√≠tulo 4 vai
explicar sobre refer√™ncias de forma mais aprofundada. Por enquanto, tudo que
voc√™ precisa saber √© que, assim como as vari√°veis, refer√™ncias s√£o imut√°veis por
padr√£o. Por isso, precisamos escrever `&mut palpite`, em vez de apenas
`&palpite`, para fazer com que o palpite seja mut√°vel.

-- ft.markdown:

Ainda n√£o finalizamos completamente esta linha de c√≥digo. Embora esta seja uma
√∫nica linha de texto, √© apenas a primeira parte de uma linha l√≥gica de c√≥digo. A
segunda parte √© a chamada para este m√©todo:

-- ft.code:
lang: rust,ignore

.expect("Falha ao ler entrada");


-- ft.markdown:

Quando voc√™ chama um m√©todo com a sintaxe `.foo()`, geralmente √© bom introduzir
uma nova linha e outro espa√ßo para ajudar a dividir linhas muito compridas.
Poder√≠amos ter feito assim:

-- ft.code:
lang: rust,ignore

io::stdin().read_line(&mut palpite).expect("Falha ao ler entrada");


-- ft.markdown:

Por√©m, uma linha muito comprida fica dif√≠cil de ler. Ent√£o √© melhor dividirmos a
linha em duas, uma para cada m√©todo chamado. Agora vamos falar sobre o que essa
linha faz.

-- ft.h3: Tratando Potenciais Falhas com o Tipo `Result`


Como mencionado anteriormente, `read_line` coloca o que o usu√°rio escreve dentro
da string que passamos como argumento, mas tamb√©m retorna um valor - neste
caso, um [`io::Result`](../../std/io/type.Result.html)<!-- ignore -->. Rust tem uma variedade de
tipos com o nome `Result` em sua biblioteca padr√£o: um [`Result`](../../std/result/enum.Result.html)
gen√©rico e as vers√µes espec√≠ficas dos subm√≥dulos, como `io::Result`.




Os tipos `Result` s√£o [*enumera√ß√µes*](ch06-00-enums.html)<!-- ignore -->, comumente chamadas
de *enums*. Uma enumera√ß√£o √© um tipo que pode ter um conjunto fixo de valores,
os quais s√£o chamados de *variantes* da enum. O Cap√≠tulo 6 vai abordar enums em
mais detalhes.



Para `Result`, as variantes s√£o `Ok` ou `Err`. `Ok` indica que a opera√ß√£o teve
sucesso, e dentro da variante `Ok` est√° o valor resultante. `Err` significa que
a opera√ß√£o falhou, e cont√©m informa√ß√µes sobre como ou por que isso ocorreu.

O prop√≥sito destes tipos `Result` √© codificar informa√ß√µes de manipula√ß√£o de
erros. Valores do tipo `Result`, assim como qualquer tipo, possuem m√©todos
definidos. Uma inst√¢ncia de `io::Result` tem um [m√©todo `expect`](../../std/result/enum.Result.html#method.expect)<!-- ignore -->
que voc√™ pode chamar. Se esta inst√¢ncia de `io::Result` √© um `Err`, `expect` vai
terminar o programa com erro e mostrar a mensagem que voc√™ passou como argumento
ao `expect`. Se o m√©todo `read_line` retornar um `Err`, provavelmente seria o
resultado de um erro vindo do sistema operacional que est√° por tr√°s. Se esta
inst√¢ncia de `io::Result` √© um `Ok`, `expect` vai obter o valor contido no `Ok`
e retorn√°-lo para que voc√™ possa us√°-lo. Neste caso, o valor √© o n√∫mero de bytes
dos dados que o usu√°rio inseriu atrav√©s da entrada padr√£o.



Se n√£o chamarmos `expect`, nosso programa vai compilar, mas vamos ter um aviso:

-- ft.code:
lang: text

\$ cargo build
   Compiling jogo_de_advinhacao v0.1.0 (file:///projects/jogo_de_advinhacao)
warning: unused `std::result::Result` which must be used
  --> src/main.rs:10:5
   |
10 |     io::stdin().read_line(&mut palpite);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: #[warn(unused_must_use)] on by default


-- ft.markdown:

Rust avisa que n√£o usamos o valor `Result`, retornado por `read_line`, indicando
que o programa deixou de tratar um poss√≠vel erro. A maneira correta de suprimir
o aviso √© realmente escrevendo um tratador de erro, mas como queremos que o
programa seja encerrado caso ocorra um problema, podemos usar `expect`. Voc√™
aprender√° sobre recupera√ß√£o de erros no Cap√≠tulo 9.

-- ft.h3: Exibindo Valores com Curingas do `println!`


Tirando a chave que delimita a fun√ß√£o `main`, h√° apenas uma linha mais a ser
discutida no c√≥digo que fizemos at√© agora, que √© a seguinte:

-- ft.code:
lang: rust,ignore

println!("Voc√™ disse: {}", guess);


-- ft.markdown:

Esta linha imprime a string na qual salvamos os dados inseridos pelo usu√°rio. O
`{}` √© um curinga que reserva o lugar de um valor. Voc√™ pode imprimir mais de um
valor usando `{}`: o primeiro conjunto de `{}` guarda o primeiro valor listado
ap√≥s a string de formata√ß√£o, o segundo conjunto guarda o segundo valor, e
assim por diante. Imprimir m√∫ltiplos valores em uma s√≥ chamada a `println!`
seria assim:

-- ft.code:
lang: rust

let x = 5;
let y = 10;

println!("x = {} e y = {}", x, y);


-- ft.markdown:

Esse c√≥digo imprime `x = 5 e y = 10`.

-- ft.h3: Testando a Primeira Parte


Vamos testar a primeira parte do jogo de advinha√ß√£o. Voc√™ pode execut√°-lo usando
`cargo run`:

-- ft.code:
lang: text

\$ cargo run
   Compiling jogo_de_advinhacao v0.1.0 (file:///projects/jogo_de_advinhacao)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
     Running `target/debug/jogo_de_advinhacao`
Advinhe o n√∫mero!
Digite o seu palpite.
6
Voc√™ disse: 6


-- ft.markdown:

Nesse ponto, a primeira parte do jogo est√° feita: podemos coletar entrada do
teclado e mostr√°-la na tela.

-- ft.h2: Gerando um N√∫mero Secreto


A seguir, precisamos gerar um n√∫mero secreto que o usu√°rio vai tentar advinhar.
O n√∫mero secreto deve ser diferente a cada execu√ß√£o, para que o jogo tenha gra√ßa
em ser jogado mais de uma vez. Vamos usar um n√∫mero aleat√≥rio entre 1 e 100,
para que o jogo n√£o seja t√£o dif√≠cil. Rust ainda n√£o inclui uma funcionalidade
de gera√ß√£o de n√∫meros aleat√≥rios em sua biblioteca padr√£o. Por√©m, a equipe Rust
fornece um [crate `rand`](https://crates.io/crates/rand).



-- ft.h3: Usando um Crate para Ter Mais Funcionalidades


Lembre-se que um *crate* √© um pacote de c√≥digo Rust. O projeto que estamos
construindo √© um *crate bin√°rio*, que √© um execut√°vel. J√° o `rand` √© um
*crate de biblioteca*, que cont√©m c√≥digo cujo objetivo √© ser usado por outros
programas.

√â no uso de crates externos que Cargo realmente brilha. Antes que possamos
escrever o c√≥digo usando `rand`, precisamos modificar o arquivo *Cargo.toml*
para incluir o crate `rand` como uma depend√™ncia. Abra o arquivo e adicione
esta linha no final, abaixo do cabe√ßalho da se√ß√£o `[dependencies]` que o Cargo
criou para voc√™:

<span class="filename">Arquivo: Cargo.toml</span>

-- ft.code:
lang: toml

[dependencies]

rand = "0.3.14"


-- ft.markdown:

No arquivo *Cargo.toml*, tudo que vem depois de um cabe√ßalho √© parte de uma
se√ß√£o que segue at√© o in√≠cio de outra. A se√ß√£o `[dependencies]` √© onde voc√™ diz
ao Cargo de quais crates externos o seu projeto depende, e quais vers√µes desses
crates voc√™ exige. Neste caso, especificamos o crate `rand` com a vers√£o
sem√¢ntica `0.3.14`. Cargo compreende [Versionamento Sem√¢ntico](https://semver.org/lang/pt-BR/)<!-- ignore -->
(√†s vezes chamado *SemVer*), um padr√£o para escrever n√∫meros de vers√µes. O
n√∫mero `0.3.14` √©, na verdade, uma forma curta de escrever `^0.3.14`, que
significa "qualquer vers√£o que tenha uma API p√∫blica compat√≠vel com a vers√£o
0.3.14".



Agora, sem mudar c√≥digo algum, vamos compilar nosso projeto, conforme mostrado
na Listagem 2-2:

-- ft.code:
lang: text

\$ cargo build
    Updating registry `https://github.com/rust-lang/crates.io-index`
 Downloading rand v0.3.14
 Downloading libc v0.2.14
   Compiling libc v0.2.14
   Compiling rand v0.3.14
   Compiling jogo_de_advinhacao v0.1.0 (file:///projects/jogo_de_advinhacao)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs


-- ft.markdown:

<span class="caption">Listagem 2-2: Resultado da execu√ß√£o de `cargo build`
depois de adicionar o crate `rand` como depend√™ncia.</span>

-- ft.markdown:

Talvez pra voc√™ apare√ßam vers√µes diferentes (mas elas s√£o todas compat√≠veis com
o c√≥digo, gra√ßas ao Versionamento Sem√¢ntico!), e as linhas talvez apare√ßam em
ordem diferente.

-- ft.markdown:

Agora que temos uma depend√™ncia externa, Cargo busca as vers√µes mais recentes de
tudo no *registro*, que √© uma c√≥pia dos dados do [Crates.io](https://crates.io).
Crates.io √© onde as pessoas do ecossistema Rust postam seus projetos
_open source_ para que os outros possam usar.



-- ft.markdown:

Ap√≥s atualizar o registro, Cargo verifica a se√ß√£o `[dependencies]` e baixa todas
as que voc√™ n√£o tem ainda. Neste caso, embora tenhamos listado apenas `rand`
como depend√™ncia, o Cargo tamb√©m puxou uma c√≥pia da `libc`, porque `rand`
depende da `libc` para funcionar. Depois de baix√°-las, o Cargo as compila e
ent√£o compila nosso projeto.

-- ft.markdown:

Se, logo em seguida, voc√™ executar `cargo build` novamente sem fazer mudan√ßas,
n√£o vai aparecer nenhuma mensagem de sa√≠da. O Cargo sabe que j√° baixou e
compilou as depend√™ncias, e voc√™ n√£o alterou mais nada sobre elas no seu arquivo
*Cargo.toml*. Cargo tamb√©m sabe que voc√™ n√£o mudou mais nada no seu c√≥digo, e
por isso n√£o o recompila. Sem nada a fazer, ele simplesmente sai. Se voc√™ abrir
*src/main.rs*, fizer uma modifica√ß√£o trivial, salvar e compilar de novo, vai
aparecer uma mensagem de apenas duas linhas:

-- ft.code:
lang: text

\$ cargo build
   Compiling jogo_de_advinhacao v0.1.0 (file:///projects/jogo_de_advinhacao)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs


-- ft.markdown:

Essas linhas mostram que o Cargo s√≥ atualiza o _build_ com a sua pequena mudan√ßa
no arquivo *src/main.rs*. Suas depend√™ncias n√£o mudaram, ent√£o o Cargo sabe que
pode reutilizar o que j√° tiver sido baixado e compilado para elas. Ele apenas
recompila a sua parte do c√≥digo.

-- ft.h4: O Arquivo *Cargo.lock* Garante _Builds_ Reproduz√≠veis


O Cargo tem um mecanismo que assegura que voc√™ pode reconstruir o mesmo artefato
toda vez que voc√™ ou outra pessoa compilar o seu c√≥digo. O Cargo vai usar apenas
as vers√µes das depend√™ncias que voc√™ especificou, at√© que voc√™ indique o
contr√°rio. Por exemplo, o que acontece se, na semana que vem, sair a vers√£o
`v0.3.15` contendo uma corre√ß√£o de bug, mas tamb√©m uma regress√£o que n√£o
funciona com o seu c√≥digo?

A resposta para isso est√° no arquivo *Cargo.lock*, que foi criado na primeira
vez que voc√™ executou `cargo build`, e agora est√° no seu diret√≥rio
*jogo_de_advinhacao*. Quando voc√™ compila o seu projeto pela primeira vez, o
Cargo descobre as vers√µes de todas as depend√™ncias que preenchem os crit√©rios
e ent√£o as escreve no arquivo *Cargo.lock*. Quando voc√™ compilar o seu projeto
futuramente, o Cargo ver√° que o arquivo *Cargo.lock* existe e usar√° as vers√µes
especificadas l√°, em vez de refazer todo o trabalho descobrir as vers√µes
novamente. Isto lhe permite ter um _build_ reproduz√≠vel automaticamente. Em
outras palavras, seu projeto vai continuar com a vers√£o `0.3.14` at√© que voc√™
fa√ßa uma atualiza√ß√£o expl√≠cita, gra√ßas ao arquivo *Cargo.lock*.

-- ft.h4: Atualizando um Crate para Obter uma Nova Vers√£o


Quando voc√™ *quiser* atualizar um crate, o Cargo tem outro comando, `update`,
que faz o seguinte:

1. Ignora o arquivo *Cargo.lock* e descobre todas as vers√µes mais recentes que
   atendem as suas especifica√ß√µes no *Cargo.toml*.
1. Se funcionar, o Cargo escreve essas vers√µes no arquivo *Cargo.lock*.

Mas, por padr√£o, o Cargo vai procurar as vers√µes maiores que `0.3.0` e menores
que `0.4.0`. Se o crate `rand` j√° tiver lan√ßado duas novas vers√µes, `0.3.15` e
`0.4.0`, voc√™ ver√° a seguinte mensagem ao executar `cargo update`:

-- ft.code:
lang: text

\$ cargo update
    Updating registry `https://github.com/rust-lang/crates.io-index`
    Updating rand v0.3.14 -> v0.3.15


-- ft.markdown:

Nesse ponto, voc√™ vai notar tamb√©m uma mudan√ßa no seu arquivo *Cargo.lock*
dizendo que a vers√£o do crate `rand` que voc√™ est√° usando agora √© a `0.3.15`. 

-- ft.markdown:

Se voc√™ quisesse usar a vers√£o `0.4.0`, ou qualquer vers√£o da s√©rie `0.4.x` do
`rand`, voc√™ teria que atualizar o seu *Cargo.toml* dessa forma:

-- ft.code:
lang: toml

[dependencies]

rand = "0.4.0"


-- ft.markdown:

Na pr√≥xima vez que voc√™ executar `cargo build`, o Cargo vai atualizar o registro
de crates dispon√≠veis e reavaliar os seus requisitos sobre o `rand` de acordo
com a nova vers√£o que voc√™ especificou.

-- ft.markdown:

H√° muito mais a ser dito sobre [Cargo](http://doc.crates.io)<!-- ignore --> e o [seu
ecossistema](http://doc.crates.io/crates-io.html)<!-- ignore --> que vai ser discutido no Cap√≠tulo 14,
mas por ora isto √© tudo que voc√™ precisa saber. Cargo facilita muito reutilizar
bibliotecas, de forma que os _rust√°ceos_ consigam escrever projetos menores que
s√£o montados a partir de diversos pacotes.




-- ft.h3: Gerando um N√∫mero Aleat√≥rio


Agora vamos *usar*, de fato, o `rand`. O pr√≥ximo passo √© atualizar o
*src/main.rs* conforme mostrado na Listagem 2-3:

<span class="filename">Arquivo: src/main.rs</span>

-- ft.code:
lang: rust,ignore

extern crate rand;

use std::io;
use rand::Rng;

fn main() {
    println!("Advinhe o n√∫mero!");

    let numero_secreto = rand::thread_rng().gen_range(1, 101);

    println!("O n√∫mero secreto √©: {}", numero_secreto);

    println!("Digite o seu palpite.");

    let mut palpite = String::new();

    io::stdin().read_line(&mut palpite)
        .expect("Falha ao ler entrada");

    println!("Voc√™ disse: {}", palpite);
}


-- ft.markdown:

<span class="caption">Listagem 2-3: Mudan√ßas necess√°rias do c√≥digo para gerar um
n√∫mero aleat√≥rio.</span>

-- ft.markdown:

Estamos adicionando a linha `extern crate rand` ao topo do arquivo para indicar
ao Rust que estamos usando uma depend√™ncia externa. Isto tamb√©m √© equivalente a
um `use rand;`, assim podemos chamar qualquer coisa que esteja no crate `rand`
prefixando-a com `rand::`.

-- ft.markdown:

Em seguida, adicionamos outra linha `use`: `use rand::Rng`. `Rng` √© um trait
que define m√©todos a serem implementados pelos geradores de n√∫meros aleat√≥rios,
e esse trait deve estar dentro do escopo para que possamos usar esses m√©todos. O
Cap√≠tulo 10 vai abordar traits em mais detalhes.

-- ft.markdown:

Tem outras duas linhas que adicionamos no meio. A fun√ß√£o `rand::thread_rng` nos
d√° o gerador de n√∫meros aleat√≥rios que vamos usar, um que √© local √† _thread_
corrente e que √© inicializado pelo sistema operacional. Depois, vamos chamar o
m√©todo `gen_range` no gerador de n√∫meros aleat√≥rios. Esse m√©todo est√° definido
pelo trait `Rng` que trouxemos ao escopo por meio do `use rand::Rng`. Este
m√©todo recebe dois argumentos e gera um n√∫mero aleat√≥rio entre eles. Ele inclui
o limite inferior mas exclui o superior, ent√£o precisamos passar `1` e `101`
para obter um n√∫mero de 1 a 100.

-- ft.markdown:

Saber quais traits devem ser usadas e quais fun√ß√µes e m√©todos de um crate
devem ser chamados n√£o √© nada trivial. As instru√ß√µes de como usar um crate
est√£o na documenta√ß√£o de cada um. Outra coisa boa do Cargo √© que voc√™ pode rodar
o comando `cargo doc --open` que vai construir localmente a documenta√ß√£o
fornecida por todas as suas depend√™ncias e abr√≠-las no seu navegador. Se voc√™
estiver interessado em outras funcionalidades do crate `rand`, por exemplo,
execute `cargo doc --open` e clique em `rand`, no menu ao lado esquerdo.

-- ft.markdown:

A segunda linha que adicionamos imprime o n√∫mero secreto. Isto √© √∫til enquanto
estamos desenvolvendo o programa para podermos test√°-lo, mas vamos retir√°-la da
vers√£o final. Um jogo n√£o √© muito interessante se ele mostra a resposta logo no
in√≠cio!

-- ft.markdown:

Tente rodar o programa algumas vezes:

-- ft.code:
lang: text

\$ cargo run
   Compiling jogo_de_advinhacao v0.1.0 (file:///projects/jogo_de_advinhacao)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
     Running `target/debug/jogo_de_advinhacao`
Advinhe o n√∫mero!
O n√∫mero secreto √©: 7
Digite o seu palpite.
4
Voc√™ disse: 4
\$ cargo run
     Running `target/debug/jogo_de_advinhacao`
Advinhe o n√∫mero!
O n√∫mero secreto √©: 83
Digite o seu palpite.
5
Voc√™ disse: 5


-- ft.markdown:

Voc√™ j√° deve obter n√∫meros aleat√≥rios diferentes, e eles devem ser todos entre 1
e 100. Bom trabalho!

-- ft.h2: Comparando o Palpite com o N√∫mero Secreto


Agora que n√≥s temos a entrada do usu√°rio e o n√∫mero secreto, vamos compar√°-los.
Esta estapa √© mostrada na Listagem 2-4:

<span class="filename">Arquivo: src/main.rs</span>

-- ft.code:
lang: rust,ignore

extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!("Advinhe o n√∫mero!");

    let numero_secreto = rand::thread_rng().gen_range(1, 101);

    println!("O n√∫mero secreto √©: {}", numero_secreto);

    println!("Digite o seu palpite.");

    let mut palpite = String::new();

    io::stdin().read_line(&mut palpite)
        .expect("Falha ao ler entrada");

    println!("Voc√™ disse: {}", palpite);

    match palpite.cmp(&numero_secreto) {
        Ordering::Less => println!("Muito baixo!"),
        Ordering::Greater => println!("Muito alto!"),
        Ordering::Equal => println!("Voc√™ acertou!"),
    }
}


-- ft.markdown:

<span class="caption">Listagem 2-4: Tratando os poss√≠veis resultados da
compara√ß√£o de dois n√∫meros.</span>

-- ft.markdown:

A primeira novidade aqui √© outro `use`, que traz ao escopo um tipo da biblioteca
padr√£o chamado `std::cmp::Ordering`. `Ordering` √© outra enum, igual a `Result`,
mas as suas variantes s√£o `Less`, `Greater` e `Equal` (elas significam menor,
maior e igual, respectivamente). Estes s√£o os tr√™s poss√≠veis resultados quando
voc√™ compara dois valores.

-- ft.markdown:

Depois, adicionamos cinco novas linhas no final que usam o tipo `Ordering`:

-- ft.code:
lang: rust,ignore

match palpite.cmp(&numero_secreto) {
    Ordering::Less => println!("Muito baixo!"),
    Ordering::Greater => println!("Muito alto!"),
    Ordering::Equal => println!("Voc√™ acertou!"),
}


-- ft.markdown:

O m√©todo `cmp` compara dois valores, e pode ser chamado a partir de qualquer
coisa que possa ser comparada. Ele recebe uma refer√™ncia de qualquer coisa que
voc√™ queira comparar. Neste caso, est√° comparando o `palpite` com o
`numero_secreto`. `cmp` retorna uma variante do tipo `Ordering`, que trouxemos
ao escopo com `use`. N√≥s usamos uma express√£o [`match`](ch06-02-match.html)<!-- ignore -->
para decidir o que fazer em seguida, com base em qual variante de `Ordering` foi
retornada pelo m√©todo `cmp`, que foi chamado com os valores `palpite` e
`numero_secreto`.



-- ft.markdown:

Uma express√£o `match` √© composta de *bra√ßos*. Um bra√ßo consiste em um *padr√£o*
mais o c√≥digo que deve ser executado se o valor colocado no in√≠cio do `match` se
encaixar no padr√£o deste bra√ßo. O Rust pega o valor passado ao `match` e o
compara com o padr√£o de cada bra√ßo na sequ√™ncia. A express√£o `match` e os
padr√µes s√£o ferramentas poderosas do Rust que lhe permitem expressar uma
variedade de situa√ß√µes que seu c√≥digo pode encontrar, e ajuda a assegurar que
voc√™ tenha tratado todas elas. Essas ferramentas ser√£o abordadas em detalhes nos
cap√≠tulos 6 e 18, respectivamente.

-- ft.markdown:

Vamos acompanhar um exemplo do que aconteceria na express√£o `match` usada aqui.
Digamos que o usu√°rio tenha colocado 50 como palpite, e o n√∫mero secreto
aleat√≥rio desta vez √© 38. Quando o c√≥digo compara 50 com 38, o m√©todo `cmp` vai
retornar `Ordering::Greater`, porque 50 √© maior que 38. `Ordering::Greater` √© o
valor passado ao `match`. Ele olha para o padr√£o `Ordering::Less` do primeiro
bra√ßo, mas o valor `Ordering::Greater` n√£o casa com `Ordering::Less`, ent√£o ele
ignora o c√≥digo desse bra√ßo e avan√ßa para o pr√≥ximo. J√° o padr√£o do pr√≥ximo
bra√ßo, `Ordering::Greater`, *casa* com `Ordering::Greater`! O c√≥digo associado a
este bra√ßo vai ser executado e mostrar `Muito alto!` na tela. A express√£o
`match` termina porque j√° n√£o tem mais necessidade de verificar o √∫ltimo bra√ßo
nesse caso particular.

-- ft.markdown:

Por√©m, o c√≥digo da Listagem 2-4 ainda n√£o vai compilar. Vamos tentar:

-- ft.code:
lang: text

\$ cargo build
   Compiling jogo_de_advinhacao v0.1.0 (file:///projects/jogo_de_advinhacao)
error types
  --> src/main.rs:23:21
   |
23 |     match palpite.cmp(&numero_secreto) {
   |                       ^^^^^^^^^^^^^^^ expected struct `std::string::String`, found integral variable
   |
   = note: expected type `&std::string::String`
   = note:    found type `&{integer}`

error: aborting due to previous error
Could not compile `jogo_de_advinhacao`.


-- ft.markdown:

O que este erro est√° dizendo √© que temos *tipos incompat√≠veis*. Rust tem um
sistema de tipos forte e est√°tico. Por√©m, Rust tamb√©m tem infer√™ncia de tipos.
Quando escrevemos `let palpite = String::new()`, Rust foi capaz de inferir que
`palpite` deveria ser uma `String`, ent√£o ele n√£o nos faz escrever o tipo. O
`numero_secreto`, por outro lado, √© de um tipo num√©rico. Existem alguns tipos
num√©ricos capazes de guardar um valor entre 1 e 100: `i32`, que √© um n√∫mero de
32 bits; `u32`, um n√∫mero de 32 bits sem sinal; `i64`, um n√∫mero de 64 bits; e
mais alguns outros. O tipo num√©rico padr√£o do Rust √© `i32`, que √© o tipo do
`numero_secreto`, a n√£o ser que adicionemos, em algum lugar, uma informa√ß√£o de
tipo que fa√ßa o Rust inferir outro tipo num√©rico. A raz√£o do erro √© que o Rust
n√£o pode comparar uma string e um tipo num√©rico.

Em √∫ltima an√°lise, queremos converter a `String` que lemos como entrada em um
tipo num√©rico de verdade, de forma que possamos compar√°-lo numericamente com o
palpite. Podemos fazer isso com mais duas linhas no corpo da fun√ß√£o `main`:

<span class="filename">Arquivo: src/main.rs</span>

-- ft.code:
lang: rust,ignore

extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!("Advinhe o n√∫mero!");

    let numero_secreto = rand::thread_rng().gen_range(1, 101);

    println!("O n√∫mero secreto √©: {}", numero_secreto);

    println!("Digite o seu palpite.");

    let mut palpite = String::new();

    io::stdin().read_line(&mut palpite)
        .expect("Falha ao ler entrada");

    let palpite: u32 = palpite.trim().parse()
        .expect("Por favor, digite um n√∫mero!");

    println!("Voc√™ disse: {}", palpite);

    match palpite.cmp(&numero_secreto) {
        Ordering::Less => println!("Muito baixo!"),
        Ordering::Greater => println!("Muito alto!"),
        Ordering::Equal => println!("Voc√™ acertou!"),
    }
}


-- ft.markdown:

As duas linhas novas s√£o:

-- ft.code:
lang: rust,ignore

let palpite: u32 = palpite.trim().parse()
    .expect("Por favor, digite um n√∫mero!");


-- ft.markdown:

N√≥s criamos uma vari√°vel chamada `palpite`. Mas espera, o programa j√° n√£o tinha
uma vari√°vel chamada `palpite`? Sim, mas o Rust nos permite *sombrear* o
`palpite` anterior com um novo. Isto √© geralmente usado em situa√ß√µes em que voc√™
quer converter um valor de um tipo em outro. O sombreamento nos permite
reutilizar o nome `palpite`, em vez de nos for√ßar a criar dois nomes √∫nicos como
`palpite_str` e `palpite`, por exemplo. (O Cap√≠tulo 3 vai cobrir sombreamento em
mais detalhes).

-- ft.markdown:

N√≥s vinculamos `palpite` √† express√£o `palpite.trim().parse()`. O `palpite`, na
express√£o, refere-se ao `palpite` original contendo a `String` de entrada do
usu√°rio. O m√©todo `trim`, em uma inst√¢ncia de `String`, vai eliminar quaisquer
espa√ßos em branco no in√≠cio e no fim. `u32` pode conter apenas caracteres
num√©ricos, mas o usu√°rio precisa pressionar <span class="keystroke">Enter</span>
para satisfazer o `read_line`. Quando o usu√°rio pressiona
<span class="keystroke">Enter</span>, um caractere de nova linha √© inserido na
string. Por exemplo, se o usu√°rio digitar <span class="keystroke">5</span> e
depois <span class="keystroke">Enter</span>, `palpite` ficaria assim: `5\n`. O
`\n` representa uma linha nova, a tecla <span class="keystroke">Enter</span>.
O m√©todo `trim` elimina o `\n`, deixando apenas `5`.

-- ft.markdown:

O [m√©todo `parse` em strings](../../std/primitive.str.html#method.parse)<!-- ignore --> converte uma string para
algum tipo de n√∫mero. Dado que ele pode interpretar uma variedade de tipos
num√©ricos, precisamos dizer ao Rust qual o tipo exato de n√∫mero n√≥s queremos, e
para isso usamos `let palpite: u32`. Os dois pontos (`:`) depois de `palpite`
informam ao Rust que estamos anotando seu tipo. O Rust tem alguns tipos
num√©ricos embutidos, o `u32` visto aqui √© um inteiro de 32 bits sem sinal. √â uma
boa escolha padr√£o para um n√∫mero positivo pequeno. Voc√™ vai aprender sobre
outros tipos num√©ricos no Cap√≠tulo 3. Al√©m disso, a anota√ß√£o `u32` neste
programa de exemplo e a compara√ß√£o com `numero_secreto` significam que o Rust
vai inferir que `numero_secreto` tamb√©m deve ser um `u32`. Ent√£o agora a
compara√ß√£o vai ser feita entre valores do mesmo tipo!



-- ft.markdown:

A chamada para `parse` poderia facilmente causar um erro. Por exemplo, se a
string contiver `Aüëç%`, n√£o haveria como converter isto em um n√∫mero. Como ele
pode falhar, o m√©todo `parse` retorna um `Result`, assim como o m√©todo
`read_line`, conforme discutido anteriormente na se√ß√£o "Tratando Potenciais
Falhas com o Tipo `Result`. Vamos tratar este `Result` da mesma forma usando o
m√©todo `expect` de novo. Se o `parse` retornar uma variante `Err` da enum
`Result`, por n√£o conseguir criar um n√∫mero a partir da string, a chamada ao
`expect` vai causar um _crash_ no jogo e exibir a mensagem que passamos a ele.
Se o `parse` conseguir converter uma string em um n√∫mero, ele vai retornar a
variante `Ok` da enum `Result` e `expect` vai retornar o n√∫mero que queremos
extrair do valor `Ok`.

-- ft.markdown:

Agora vamos executar o programa!

-- ft.code:
lang: text

\$ cargo run
   Compiling jogo_de_advinhacao v0.1.0 (file:///projects/jogo_de_advinhacao)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43 secs
     Running `target/jogo_de_advinhacao`
Advinhe o n√∫mero!
O n√∫mero secreto √©: 58
Digite o seu palpite.
  76
Voc√™ disse: 76
Muito alto!


-- ft.markdown:

Boa! At√© mesmo colocando alguns espa√ßos antes de digitar o palpite, o programa
ainda descobriu que o palpite do usu√°rio √© 76. Execute o programa mais algumas
vezes para verificar os diferentes comportamentos com diferentes tipos de
entrada: advinhe o n√∫mero corretamente, digite um n√∫mero muito alto, e digite um
n√∫mero muito baixo.

-- ft.markdown:

Agora j√° temos a maior parte do jogo funcionando, mas o usu√°rio s√≥ consegue dar
um palpite uma vez. Vamos mudar isso adicionando la√ßos!

-- ft.h2: Permitindo M√∫ltiplos Palpites Usando _Looping_


A palavra-chave `loop` nos d√° um la√ßo (_loop_) infinito. Use-a para dar aos
usu√°rios mais chances de advinhar o n√∫mero:

<span class="filename">Arquivo: src/main.rs</span>

-- ft.code:
lang: rust,ignore

extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!("Advinhe o n√∫mero!");

    let numero_secreto = rand::thread_rng().gen_range(1, 101);

    println!("O n√∫mero secreto √©: {}", numero_secreto);

    loop {
        println!("Digite o seu palpite.");

        let mut palpite = String::new();

        io::stdin().read_line(&mut palpite)
            .expect("Falha ao ler entrada");

        let palpite: u32 = palpite.trim().parse()
            .expect("Por favor, digite um n√∫mero!");

        println!("Voc√™ disse: {}", palpite);

        match palpite.cmp(&numero_secreto) {
            Ordering::Less => println!("Muito baixo!"),
            Ordering::Greater => println!("Muito alto!"),
            Ordering::Equal => println!("Voc√™ acertou!"),
        }
    }
}


-- ft.markdown:

Como voc√™ pode ver, movemos tudo para dentro do la√ßo a partir da mensagem
pedindo o palpite do usu√°rio. Certifique-se de indentar essas linhas mais quatro
espa√ßos cada uma, e execute o programa novamente. Repare que h√° um novo
problema, porque o programa est√° fazendo exatamente o que dissemos para ele
fazer: pedir sempre outro palpite! Parece que o usu√°rio n√£o consegue sair!

-- ft.markdown:

O usu√°rio pode sempre interromper o programa usando as teclas
<span class="keystroke">ctrl-c</span>. Mas h√° uma outra forma de escapar deste
monstro insaci√°vel que mencionamos na discuss√£o do m√©todo `parse`, na se√ß√£o
"Comparando o Palpite com o N√∫mero Secreto": se o usu√°rio fornece uma resposta
n√£o-num√©rica, o programa vai sofrer um _crash_. O usu√°rio pode levar vantagem
disso para conseguir sair, como mostrado abaixo:

-- ft.code:
lang: text

\$ cargo run
   Compiling jogo_de_advinhacao v0.1.0 (file:///projects/jogo_de_advinhacao)
     Running `target/jogo_de_advinhacao`
Advinhe o n√∫mero!
O n√∫mero secreto √©: 59
Digite o seu palpite.
45
Voc√™ disse: 45
Muito baixo!
Digite o seu palpite.
60
Voc√™ disse: 60
Muito alto!
Digite o seu palpite.
59
Voc√™ disse: 59
Voc√™ acertou!
Digite o seu palpite.
sair
thread 'main' panicked at 'Por favor, digite um n√∫mero!: ParseIntError { kind: InvalidDigit }', src/libcore/result.rs:785
note: Run with `RUST_BACKTRACE=1` for a backtrace.
error: Process didn't exit successfully: `target/debug/jogo_de_advinhacao` (exit code: 101)


-- ft.markdown:

Digitar `sair`, na verdade, sai do jogo, mas isso tamb√©m acontece com qualquer
outra entrada n√£o num√©rica. Por√©m, isto n√£o √© o ideal. Queremos que o jogo
termine automaticamente quando o n√∫mero √© advinhado corretamente.

-- ft.h3: Saindo Ap√≥s um Palpite Correto


Vamos programar o jogo para sair quando o usu√°rio vencer, colocando um `break`:

<span class="filename">Arquivo: src/main.rs</span>

-- ft.code:
lang: rust,ignore

extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!("Advinhe o n√∫mero!");

    let numero_secreto = rand::thread_rng().gen_range(1, 101);

    println!("O n√∫mero secreto √©: {}", numero_secreto);

    loop {
        println!("Digite o seu palpite.");

        let mut palpite = String::new();

        io::stdin().read_line(&mut palpite)
            .expect("Falha ao ler entrada");

        let palpite: u32 = palpite.trim().parse()
            .expect("Por favor, digite um n√∫mero!");

        println!("Voc√™ disse: {}", palpite);

        match palpite.cmp(&numero_secreto) {
            Ordering::Less => println!("Muito baixo"),
            Ordering::Greater => println!("Muito alto!"),
            Ordering::Equal => {
                println!("Voc√™ acertou!");
                break;
            }
        }
    }
}


-- ft.markdown:

Adicionando a linha `break` ap√≥s o `Voc√™ acertou!`, o programa vai sair do la√ßo
quando o usu√°rio advinhar corretamente o n√∫mero secreto. Sair do la√ßo tamb√©m
significa sair do programa, pois o la√ßo √© a √∫ltima parte da `main`.

-- ft.h3: Tratando Entradas Inv√°lidas


Para refinar ainda mais o comportamento do jogo, em vez de causar um _crash_ no
programa quando o usu√°rio insere uma entrada n√£o num√©rica, vamos fazer o jogo
ignor√°-la para que o usu√°rio possa continuar tentando. Podemos fazer isso
alterando a linha em que o `palpite` √© convertido de `String` para `u32`:

-- ft.code:
lang: rust,ignore

let palpite: u32 = match palpite.trim().parse() {
    Ok(num) => num,
    Err(_) => continue,
};


-- ft.markdown:

Trocando uma chamada a `expect` por uma express√£o `match` √© a forma como voc√™
geralmente deixa de causar um _crash_ em um erro e passa a trat√°-lo, de fato.
Lembre-se que o m√©todo `parse` retorna um valor do tipo `Result`, uma enum que
cont√©m a variante `Ok` ou `Err`. Estamos usando um `match` aqui, assim como
fizemos com o `Ordering` resultante do m√©todo `cmp`.

-- ft.markdown:

Se o `parse` consegue converter a string em um n√∫mero, ele vai retornar um `Ok`
contendo o n√∫mero resultante. Esse valor `Ok` vai casar com o padr√£o do primeiro
bra√ßo, e o `match` vai apenas retornar o valor `num` produzido pelo `parse` e
colocado dentro do `Ok`. Esse n√∫mero vai acabar ficando exatamente onde
queremos, na vari√°vel `palpite` que estamos criando. 

-- ft.markdown:

Se o `parse` *n√£o* conseguir converter a string em um n√∫mero, ele vai retornar
um `Err` que cont√©m mais informa√ß√µes sobre o erro. O valor `Err` n√£o casa com o
padr√£o `Ok(num)` do primeiro bra√ßo do `match`, mas casa com o padr√£o `Err(_)` do
segundo bra√ßo. O `_` √© um valor "pega tudo". Neste exemplo, estamos dizendo que
queremos casar todos os valores `Err`, n√£o importa qual informa√ß√£o h√° dentro
deles. Ent√£o o programa vai executar o c√≥digo do segundo bra√ßo, `continue`, que
significa ir para a pr√≥xima itera√ß√£o do `loop` e pedir outro palpite.
Efetivamente, o programa ignora todos os erros que o `parse` vier a encontrar!

-- ft.markdown:

Agora, tudo no programa deve funcionar como esperado. Vamos tentar execut√°-lo
usando o comando `cargo run`:

-- ft.code:
lang: text

\$ cargo run
   Compiling jogo_de_advinhacao v0.1.0 (file:///projects/jogo_de_advinhacao)
     Running `target/jogo_de_advinhacao`
Advinhe o n√∫mero!
O n√∫mero secreto √©: 61
Digite o seu palpite.
10
Voc√™ disse: 10
Muito baixo!
Digite o seu palpite.
99
Voc√™ disse: 99
Muito alto!
Digite o seu palpite.
foo
Digite o seu palpite.
61
Voc√™ disse: 61
Voc√™ acertou!


-- ft.markdown:

Demais! Com apenas um √∫ltimo ajuste, vamos finalizar o jogo de adivinha√ß√£o:
lembre-se que o programa ainda est√° mostrando o n√∫mero secreto. Isto foi bom
para testar, mas estraga o jogo. Vamos apagar o `println!` que revela o n√∫mero
secreto. A Listagem 2-5 mostra o c√≥digo final:

-- ft.markdown:

<span class="filename">Arquivo: src/main.rs</span>

-- ft.code:
lang: rust,ignore

extern crate rand;

use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!("Advinhe o n√∫mero!");

    let numero_secreto = rand::thread_rng().gen_range(1, 101);

    loop {
        println!("Digite o seu palpite.");

        let mut palpite = String::new();

        io::stdin().read_line(&mut palpite)
            .expect("Falha ao ler entrada");

        let palpite: u32 = match palpite.trim().parse() {
            Ok(num) => num,
            Err(_) => continue,
        };

        println!("Voc√™ disse: {}", palpite);

        match palpite.cmp(&numero_secreto) {
            Ordering::Less => println!("Muito baixo!"),
            Ordering::Greater => println!("Muito alto!"),
            Ordering::Equal => {
                println!("Voc√™ acertou!");
                break;
            }
        }
    }
}


-- ft.markdown:

<span class="caption">Listagem 2-5: C√≥digo completo do jogo de advinha√ß√£o.
</span>

-- ft.h2: Resumo


Neste ponto, voc√™ construiu com sucesso o jogo de adivinha√ß√£o! Parab√©ns!

Este projeto foi uma forma pr√°tica de apresentar v√°rios conceitos novos de Rust:
`let`, `match`, m√©todos, fun√ß√µes associadas, uso de crates externos, e outros.
Nos pr√≥ximos cap√≠tulos, voc√™ vai aprender sobre esses conceitos em mais
detalhes. O Cap√≠tulo 3 aborda conceitos que a maioria das linguagens de
programa√ß√£o tem, como vari√°veis, tipos de dados e fun√ß√µes, e mostra como us√°-los
em Rust. O Cap√≠tulo 4 explora posse (_ownership_), que √© a caracter√≠stica do
Rust mais diferente das outras linguagens. O Cap√≠tulo 5 discute structs e a
sintaxe de m√©todos, e o Cap√≠tulo 6 se dedica a explicar enums.
