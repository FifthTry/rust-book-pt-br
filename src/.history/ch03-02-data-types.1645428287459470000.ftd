-- ft.doc-page:
toc: $ft.toc

-- ft.h1: Tipos de dados


Todo valor em Rust √© um *tipo de dado*, que informa ao Rust que tipos de
dados est√£o sendo especificados para que saiba como trabalhar com esses dados. Vamos olhar para
dois subconjuntos de tipos de dados: escalar e composto.

Tenha em mente que Rust √© uma linguagem de *tipagem est√°tica*, o que significa
que deve conhecer os tipos de todas as vari√°veis em tempo de compila√ß√£o. O compilador
geralmente pode inferir que tipo queremos com base no valor e como o usamos. Nos casos
em que s√£o √© poss√≠vel v√°rios tipos de dados, como quando convertemos uma `String` em um tipo num√©rico
usando `parse` na se√ß√£o "Comparando o Adivinha ao N√∫mero Secreto" no
Cap√≠tulo 2, devemos adicionar uma anota√ß√£o de tipo, como a seguinte:

-- ft.code:
lang: rust

let guess: u32 = "42".parse().expect("N√£o √© um n√∫mero!");


-- ft.markdown:

Se n√£o adicionarmos uma anota√ß√£o de tipo, Rust ir√° mostrar o seguinte erro,
que significa que o compilador precisa de mais informa√ßoes para saber qual tipo de dados
queremos usar:

-- ft.code:
lang: text

error annotations needed
 --> src/main.rs:2:9
  |
2 |     let guess = "42".parse().expect("N√£o √© um n√∫mero!");
  |         ^^^^^
  |         |
  |         cannot infer type for `_`
  |         consider giving `guess` a type


-- ft.markdown:

Voc√™ ver√° anota√ß√µes de tipos diferentes para outros tipos de dados.

-- ft.h3: Tipos escalares


Um tipo *escalar* representa um valor √∫nico. Rust tem quatro tipos escalares prim√°rios:
inteiros, n√∫meros de ponto flutuante, booleanos e caracteres. Voc√™ pode reconhecer
esses tipos de outras linguagens de programa√ß√£o. Vamos pular para como eles funcionam no Rust.

-- ft.h3: Tipos inteiros


Um *inteiro* √© um n√∫mero sem a parte fracion√°ria. Usamos
um tipo inteiro no Cap√≠tulo 2, o tipo `u32`. Esse tipo de
declara√ß√£o indica que
o valor associado deve ser um inteiro sem sinal (tipos inteiros com sinal come√ßam com `i`, em vez de `u`) que ocupa 32 bits de espa√ßo. Tabela 3-1 mostra
os tipos inteiros internos ao Rust. Cada variante est√° na
coluna com sinal e sem sinal (por exemplo, `i16`) pode ser usada para declarar um valor do tipo
inteiro.

<span class="caption">Tabela 3-1: Tipos inteiros no Rust</span>

| Tamanho | Signed  | Unsigned |
|---------|---------|----------|
| 8-bit   | `i8`    | `u8`     |
| 16-bit  | `i16`   | `u16`    |
| 32-bit  | `i32`   | `u32`    |
| 64-bit  | `i64`   | `u64`    |
| arch    | `isize` | `usize`  |

Cada variante pode ser com ou sem sinal e ter tamanho expl√≠cito.
*Signed* e *unsigned* refere-se √† possibilidade do n√∫mero ser
negativo ou positivo - em outras palavras, se o n√∫mero precisa de um sinal
com ele (signed) ou se sempre for
positivo pode ser representado sem um sinal (unsigned). √â como escrevemos n√∫meros no papel: Quando
o sinal importa, o n√∫mero √© mostrado com um sinal de mais ou menos; contudo,
quando √© seguro assumir que o n√∫mero √© positivo, √© mostrado sem sinal.
N√∫meros com sinais s√£o armazenados usando a representa√ß√£o complemento de dois (se voc√™ n√£o tiver
certeza do que √© isso, voc√™ pode procurar sobre isso na internet; uma explica√ß√£o est√° fora do escopo
deste livro).

Cada variante com sinal pode armazenar n√∫meros de -(2<sup>n - 1</sup>) at√© 2<sup>n -
1</sup> - 1 incluso, sendo *n* o n√∫mero de bits que varia de acordo com o uso. Ent√£o, um
`i8` pode armazenar n√∫meros de -(2<sup>7</sup>) at√© 2<sup>7</sup> - 1, que √©  igual
a -128 at√© 127. Variantes sem sinal pode armazenar n√∫meros de 0 at√© 2<sup>n</sup> - 1,
entao um `u8` pode armazenar n√∫meros de 0 at√© 2<sup>8</sup> - 1, que √© de 0 at√© 255.

Al√©m disso, os tipos `isize` e `usize` dependem do computador em que seu programa
est√° rodando: 64 bits se estiver em uma arquitetura de 64-bit e 32 bits
se sua arquitetura for 32-bit.

Voc√™ pode criar inteiros literais em qualquer uma das formas mostrada na Tabela 3-2. Observe
que todos os literais de n√∫meros, exceto o byte literal, permitem um sufixo de tipo,
como por exemplo, `57u8` e `_` s√£o separadores visuais, tal como `1_000`.

<span class="caption">Tabela 3-2: Inteiros Literais no Rust</span>

| N√∫meros literais    | Exemplo       |
|---------------------|---------------|
| Decimal             | `98_222`      |
| Hexadecimal         | `0xff`        |
| Octal               | `0o77`        |
| Bin√°rio             | `0b1111_0000` |
| Byte (`u8` apenas)  | `b'A'`        |

Ent√£o como voc√™ pode saber qual tipo de inteiro usar? Se sentir-se inseguro, as
escolhas padr√µes do Rust geralmente s√£o boas, e por padr√£o os inteiros s√£o do tipo `i32`: Esse
tipo geralmente √© o mais r√°pido, at√© em sistemas de 64-bit. A
principal situa√ß√£o em que voc√™ usuaria `isize` ou `usize` √© indexar algum tipo de cole√ß√£o.

-- ft.h4: Tipos de ponto flutuante


Rust tamb√©m tem dois tipos primitivos para *n√∫meros de ponto flutuante*, que s√£o
n√∫meros com casas decimais. Os pontos flutuantes do Rust s√£o
`f32` e `f64`, que t√™m respectivamente os tamanhos de 32 e 64 bits. O tipo padr√£o √© `f64`
porque nos processadores modernos, a velocidade √© quase a mesma que em um `f32`, mas possui
maior precis√£o.

Esse exemplo mostra n√∫meros de ponto flutuante em a√ß√£o:

<span class="filename">Nome do arquivo: src/main.rs</span>

-- ft.code:
lang: rust

fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}


-- ft.markdown:

N√∫meros em ponto flutuante s√£o representados de acordo com o padr√£o IEEE-754. O tipo
`f32` √© de precis√£o simples e `f64` tem precis√£o dupla.

-- ft.h4: Opera√ß√µes num√©ricas


Rust suporta opera√ß√µes matem√°ticas b√°sicas, voc√™ pode esperar
todas as seguintes opera√ß√µes para todos os tipos num√©ricos: adi√ß√£o, subtra√ß√£o, multiplica√ß√£o, divis√£o e resto.
O c√≥digo a seguir mostra como usar cada declara√ß√£o `let`:

<span class="filename">Nome do arquivo: src/main.rs</span>

-- ft.code:
lang: rust

fn main() {
    // adi√ß√£o
    let soma = 5 + 10;

    // subtra√ß√£o
    let diferenca = 95.5 - 4.3;

    // multiplica√ß√£o
    let produto = 4 * 30;

    // divis√£o
    let quociente = 56.7 / 32.2;

    // resto
    let resto = 43 % 5;
}


-- ft.markdown:

Cada express√£o nessas declara√ß√µes, usa um operador matem√°tico e computa um √∫nico valor,
que ent√£o √© atribu√≠do √† uma vari√°vel.
Ap√™ndice B cont√©m uma lista de todos os operadores que o Rust suporta.

-- ft.h4: O tipo booleano


Como em diversas linguagens de programa√ß√£o, o tipo Booleano em Rust possue dois valores
poss√≠veis: `true` e `false`. O tipo Booleano no Rust √© especificado usando `bool`.
Por exemplo:

<span class="filename">Nome do arquivo: src/main.rs</span>

-- ft.code:
lang: rust

fn main() {
    let t = true;

    let f: bool = false; // com tipo expl√≠cito
}


-- ft.markdown:

A principal utiliza√ß√£o de valores Booleanos √© atrav√©s dos condicionais, como um `if`.
Veremos como a express√£o `if` funciona em Rust na se√ß√£o
"Controle de fluxo".

-- ft.h4: O tipo de caractere


At√© agora trabalhamos apenas com n√∫meros, mas Rust tamb√©m suporta letras. O `char`
√© o tipo mais primitivo da linguaguem e o seguinte c√≥digo
mostra uma forma de utiliz√°-lo. (Observe que o `char` √©
espec√≠ficado com aspas simples, √© o oposto de strings, que usa aspas duplas.)

<span class="filename">Nome do arquivo: src/main.rs</span>

-- ft.code:
lang: rust

fn main() {
    let c = 'z';
    let z = '‚Ñ§';
    let heart_eyed_cat = 'üòª';
}


-- ft.markdown:

O tipo `char` representa um valor unicode, o que quer dizer que voc√™ pode
armazenar muito mais que apenas ASCII. Letras com acentua√ß√£o; ideogramas chin√™s, japon√™s e
coreano; emoji; e caracteres n√£o vis√≠veis s√£o v√°lidos.
Valores Unicode v√£o de `U+0000` at√© `U+D7FF` e `U+E000` at√©
`U+10FFFF` incluso. Contudo, um "caractere" n√£o √© realmente um conceito em Unicode,
ent√£o a sua intui√ß√£o de o que √© um "caractere" pode n√£o combinar com o que √© um
`char` em Rust. Discutiremos esse t√≥pico em detalhes em "Strings" no Cap√≠tulo 8.

-- ft.h3: Tipos compostos


*Tipos compostos* podem agrupar v√°rios valores em um √∫nico tipo. Rust tem dois
tipos primitivos compostos: tuplas e vetores.

-- ft.h4: O tipo tuplaero de valores


Uma tupla √© de modo geral uma forma de agrupar um certo n√∫mero de valores
com uma vari√°vel do tipo composto.

Criamos uma tupla escrevendo uma lista de valores separados por v√≠rgula
dentro de par√™nteses. Cada posi√ß√£o da tupla tem um tipo e os tipos dos elementos
da tupla n√£o necessitam serem iguais.
Adicionamos anota√ß√µes de tipo neste exemplo:

<span class="filename">Nome do arquivo: src/main.rs</span>

-- ft.code:
lang: rust

fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}


-- ft.markdown:

A vari√°vel `tup` liga-se a tupla, porque uma tupla √© considerada
um √∫nico elemento composto. Para pegar os valores da tupla individualmente, podemos usar
a correspond√™ncia de padr√µes para desestruturar o valor de uma tupla, como este:

-- ft.markdown:

<span class="filename">Nome do arquivo: src/main.rs</span>

-- ft.code:
lang: rust

fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!("O valor do y √©: {}", y);
}


-- ft.markdown:

Esse primeito programa cria uma tupla e vincula ela √† vari√°vel `tup`. Em seguida,
ele usa um padr√£o com `let` para tirar `tup` e tranform√°-lo em tr√™s vari√°veis
separadas, `x`, `y` e `z`. Isso √© chamado de *desestrutura√ß√£o*, porque quebra uma √∫nica tupla
em tr√™s partes. Finalmente, o programa exibe o valor de `y`,
que √© `6.4`.

-- ft.markdown:

Al√©m de desestruturar atrav√©s da correspond√™ncia de padr√µes, podemos
acessar diretamente um elemento da tupla usando um ponto (`.`) como √≠ndice
do valor que queremos acessar. Por exemplo:

-- ft.markdown:

<span class="filename">Nome do arquivo: src/main.rs</span>

-- ft.code:
lang: rust

fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let quinhentos = x.0;

    let seis_ponto_quatro = x.1;

    let um = x.2;
}


-- ft.markdown:

Esse programa cria uma tupla, `x`, e ent√£o cria uma vari√°vel para cada
elemento usando seus √≠ndices. Como ocorre nas maiorias das linguagens, o primeiro
√≠ndice em uma tupla √© o 0.

-- ft.h4: O tipo matriz


Uma outra maneira de ter uma cole√ß√£o de v√°rios valores √© uma *matriz*. Diferentemente
de uma tupla, todos os elementos de uma matriz devem ser do mesmo tipo.
Matrizes em Rust s√£o diferentes de matrizes de outras linguagens, porque matrizes em Rust s√£o de
tamanhos fixos: uma vez declarado, eles n√£o podem aumentar ou diminuir de tamanho.

Em Rust, os valores que entram numa matriz s√£o escritos em uma lista separados
por v√≠rgulas dentro de colchetes:

<span class="filename">Nome do arquivo: src/main.rs</span>

-- ft.code:
lang: rust

fn main() {
    let a = [1, 2, 3, 4, 5];
}


-- ft.markdown:

Matrizes s√£o √∫teis quando voc√™ deseja que seus dados sejam alocados em pilha do que
no heap (discutiremos mais sobre pilha e heap no Cap√≠tulo 4), ou quando
voc√™ quer garantir que sempre ter√° um n√∫mero fixo de elementos. Uma matriz n√£o
√© t√£o flex√≠vel como um vetor. Um vetor √© de tipo semelhante,
fornecido pela biblioteca padr√£o que *√©* permitido diminuir ou aumentar o tamanho.
Se voc√™ n√£o tem certeza se deve usar uma matriz ou vetor, voc√™ provavlemente usar√° um
vetor. O Cap√≠tulo 8 discute sobre vetores com mais detalhes.

-- ft.markdown:

Um exemplo de quando voc√™ poderia necessitar usar uma matriz no lugar de um vetor √© 
um programa em que voc√™ precisa saber o nome dos meses do ano. √â improv√°vel
que tal programa deseje adicionar ou remover meses, ent√£o voc√™ pode usar uma matriz
porque voc√™ sabe que sempre conter√° 12 itens:

-- ft.code:
lang: rust

let meses = ["Janeiro", "Fevereiro", "Mar√ßo", "Abril", "Maio", "Junho", "Julho",
              "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"];


-- ft.h5: Acessando um elemento da matriz


Uma matriz √© um peda√ßo da mem√≥ria alocada na pilha. Voc√™ pode acessar
os elementos da matriz usando indices, como a seguir:

<span class="filename">Nome do arquivo: src/main.rs</span>

-- ft.code:
lang: rust

fn main() {
    let a = [1, 2, 3, 4, 5];

    let primeiro = a[0];
    let segundo = a[1];
}


-- ft.markdown:

Neste exemplo, a vari√°vel chamada `primeiro` ir√° pegar o valor `1`, porque
√© o valor indexado por `[0]` na matriz. A vari√°vel chamada `segundo` ir√°
pegar o valor `2`, do indice `[1]` da matriz.

-- ft.h5: Acesso inv√°lido a elemento da matriz


O que acontece se voc√™ tentar acessar um elemento da matriz que est√° al√©m do fim
da matriz? Digamos que voc√™ mude o exemplo para o c√≥digo a seguir, que ser√° compilado,
mas existe um erro quando for executar:

<span class="filename">Nome do arquivo: src/main.rs</span>

-- ft.code:
lang: rust,ignore

fn main() {
    let a = [1, 2, 3, 4, 5];
    let indice = 10;

    let elemento = a[indice];

    println!("O valor do elemento √©: {}", elemento);
}


-- ft.markdown:

Executando esse c√≥digo usando `cargo run`, √© produzido o seguinte resultado:

-- ft.code:
lang: text

\$ cargo run
   Compiling arrays v0.1.0 (file:///projects/arrays)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running `target/debug/arrays`
thread '<main>' panicked at 'index out of bounds: the len is 5 but the index is
 10', src/main.rs:6
note: Run with `RUST_BACKTRACE=1` for a backtrace.


-- ft.markdown:

A compila√ß√£o n√£o produz nenhum erro, mas o programa resulta um
erro *em tempo de execu√ß√£o* e n√£o uma sa√≠da com sucesso. Quando voc√™
tenta acessar um elemento usando indexa√ß√£o, o Rust verifica se o √≠ndice especificado √© menor que o tamaho
da matriz. Se o √≠ndice √© maior que o tamanho, o Rust vai entrar
em *p√¢nico*, que √© o termo usado pelo Rust quando um programa resulta em erro.

-- ft.markdown:

Esse √© o primeiro exemplo dos pric√≠pios de seguran√ßa do Rust em a√ß√£o. Em v√°rias
linguagens de baixo n√≠vel, esse tipo de verifica√ß√£o n√£o √© feita e quando voc√™ fornece um
√≠ndice incorreto, mem√≥ria inv√°lida pode ser acessada. Rust protege voc√™ deste tipo
de erro ao sair imediatamente, em vez de permitir o acesso √† mem√≥ria e
continuando. O Cap√≠tulo 9 discute mais sobre o tratamento de erros do Rust.
